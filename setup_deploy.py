from __future__ import annotations

import argparse
import os
import getpass
from pathlib import Path

# parse args to get the version
parser = argparse.ArgumentParser(
    description="Generate deployment files from templates."
)

APP_NAME = "BoilerPlate"

DO_NOT_EDIT_HEADER = """
# DO NOT EDIT THIS FILE, IT IS AUTO-GENERATED BY THE SETUP_DEPLOY.PY SCRIPT, EDIT THE TEMPLATE FILES IN THE backend/<version>/tooling/build DIRECTORY INSTEAD.
# THEN RUN python3 setup_deploy.py --this --version <version>
"""

def load_text(path: Path) -> str:
    with path.open("r", encoding="utf-8") as f:
        return f.read()


def save_text(path: Path, content: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    # Force LF newlines so files are ready for Linux deployment even if run on Windows
    with path.open("w", encoding="utf-8", newline="\n") as f:
        f.write(content)


def render_content(
    raw: str, username: str, project_path: str, version: str, port: int
) -> str:
    """Apply ordered substitutions for placeholders."""
    rendered = raw
    # Normalize project_path to have no trailing slash
    project_path = project_path.rstrip("/")
    # Replace placeholders
    rendered = rendered.replace("&USERNAME", username)
    rendered = rendered.replace("&VERSION", version)
    rendered = rendered.replace("&APP_NAME", APP_NAME)
    rendered = rendered.replace("&PROJECT_ROOT", project_path)
    rendered = rendered.replace("&LISTEN_PORT", str(port))
    return rendered


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate deployment files from templates."
    )
    parser.add_argument(
        "--this",
        action="store_true",
        help="Use current user and this script's directory as project root",
    )
    parser.add_argument(
        "--username", required=False, help="Target Linux username for deployment files"
    )
    parser.add_argument(
        "--project-path",
        required=False,
        help="Absolute path on the server to the project root (e.g. /home/alice/Dev/NewApp)",
    )
    parser.add_argument(
        "--output-dir",
        default="instance",
        help="Directory to write generated files into (default: build)",
    )
    parser.add_argument(
        "--version",
        default="v1",
        help="Version to use for the deployment (default: v1)",
    )
    parser.add_argument(
        "--port",
        type=int,
        default=5077,
        help="Port to use for the deployment (default: 5077)",
    )

    args = parser.parse_args()
    repo_root = Path(__file__).parent.resolve()

    BUILD_TEMPLATE_DIR = f"backend/{args.version}/tooling/build"

    templates: dict[str, str] = {
         # source -> destination relative to --output-dir
         f"{BUILD_TEMPLATE_DIR}/nginx.conf": f"{args.version}/deploy/nginx.conf",
         f"{BUILD_TEMPLATE_DIR}/service.service": f"{args.version}/deploy/service.service",
         f"{BUILD_TEMPLATE_DIR}/gunicorn.conf.py": f"{args.version}/deploy/gunicorn.conf.py",
         f"{BUILD_TEMPLATE_DIR}/setup.sh": f"{args.version}/deploy/setup.sh",
     }

    # Derive inputs based on provided flags
    if args.this and args.project_path:
        raise SystemExit("--this cannot be combined with --project-path")

    if args.this:
        if args.username:
            username = args.username
        else:
            username = getpass.getuser()
        project_path = str(repo_root)
    else:
        if not args.username or not args.project_path:
            raise SystemExit(
                "Provide both --username and --project-path, or use --this"
            )
        username = args.username
        project_path = args.project_path

    for src_rel, dst_rel in templates.items():
        src_path = repo_root / src_rel
        if not src_path.exists():
            raise FileNotFoundError(f"Template not found: {src_path}")

        raw = load_text(src_path)
        rendered = render_content(raw, username, project_path, args.version, args.port)

        dst_root = repo_root / args.output_dir
        dst_path = dst_root / Path(dst_rel)
        save_text(dst_path, DO_NOT_EDIT_HEADER + rendered)
        print(f"Wrote {dst_path}")

    # Print follow-up commands for Linux servers
    if not project_path.startswith("/"):
        raise SystemExit("Project path must be an absolute path")

    commands = [
        f"chmod +x {project_path}/instance/{args.version}/deploy/setup.sh",
        f". {project_path}/instance/{args.version}/deploy/setup.sh",
    ]

    print("--------------------------------")
    print("Run the following commands on the server to deploy the application:")
    print("--------------------------------")
    print("\n".join(commands))


if __name__ == "__main__":
    main()
